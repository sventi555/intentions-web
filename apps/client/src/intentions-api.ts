/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Intentions API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

export type FollowUserHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type FollowUser201 = unknown | null;

export type FollowUser404 = {
  message: string;
};

export type RemoveFollowHeaders = {
authorization: string;
};

export type RemoveFollowBodyDirection = typeof RemoveFollowBodyDirection[keyof typeof RemoveFollowBodyDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemoveFollowBodyDirection = {
  to: 'to',
  from: 'from',
} as const;

export type RemoveFollowBody = {
  direction: RemoveFollowBodyDirection;
};

/**
 * @nullable
 */
export type RemoveFollow204 = unknown | null;

export type RemoveFollow400 = {
  message: string;
};

export type RespondToFollowHeaders = {
authorization: string;
};

export type RespondToFollowBodyAction = typeof RespondToFollowBodyAction[keyof typeof RespondToFollowBodyAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RespondToFollowBodyAction = {
  accept: 'accept',
  decline: 'decline',
} as const;

export type RespondToFollowBody = {
  action: RespondToFollowBodyAction;
};

/**
 * @nullable
 */
export type RespondToFollow200 = unknown | null;

export type RespondToFollow404 = {
  message: string;
};

export type RespondToFollow412 = {
  message: string;
};

export type CreateIntentionHeaders = {
authorization: string;
};

export type CreateIntentionBody = {
  /** @minLength 1 */
  name: string;
};

/**
 * @nullable
 */
export type CreateIntention201 = unknown | null;

export type CreateIntention409 = {
  message: string;
};

export type CreatePostHeaders = {
authorization: string;
};

export type CreatePostBody = {
  intentionId: string;
  image?: string;
  description?: string;
};

/**
 * @nullable
 */
export type CreatePost201 = unknown | null;

export type CreatePost404 = {
  message: string;
};

export type UpdatePostHeaders = {
authorization: string;
};

export type UpdatePostBody = {
  description?: string;
};

/**
 * @nullable
 */
export type UpdatePost200 = unknown | null;

export type UpdatePost404 = {
  message: string;
};

export type DeletePostHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type DeletePost204 = unknown | null;

export type CreateUserBody = {
  username: string;
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateUser201 = unknown | null;

export type CreateUser400 = {
  message: string;
};

export type CreateUser409 = {
  message: string;
};

export type UpdateUserHeaders = {
authorization: string;
};

export type UpdateUserBody = {
  image?: string;
};

/**
 * @nullable
 */
export type UpdateUser200 = unknown | null;

export type CreateCommentHeaders = {
authorization: string;
};

export type CreateCommentBody = {
  postId: string;
  body: string;
};

/**
 * @nullable
 */
export type CreateComment201 = unknown | null;

export type CreateComment404 = {
  message: string;
};

export type DeleteCommentHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type DeleteComment204 = unknown | null;

export type followUserResponse201 = {
  data: FollowUser201
  status: 201
}

export type followUserResponse404 = {
  data: FollowUser404
  status: 404
}
    
export type followUserResponseSuccess = (followUserResponse201) & {
  headers: Headers;
};
export type followUserResponseError = (followUserResponse404) & {
  headers: Headers;
};

export type followUserResponse = (followUserResponseSuccess | followUserResponseError)

export const getFollowUserUrl = (userId: string,) => {


  

  return `http://localhost:3001/follows/${userId}`
}

export const followUser = async (userId: string,
    headers: FollowUserHeaders, options?: RequestInit): Promise<followUserResponse> => {
  
  const res = await fetch(getFollowUserUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { ...headers, ...options?.headers }
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: followUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as followUserResponse
}




export const getFollowUserMutationOptions = <TError = FollowUser404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext> => {

const mutationKey = ['followUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof followUser>>, {userId: string;headers: FollowUserHeaders}> = (props) => {
          const {userId,headers} = props ?? {};

          return  followUser(userId,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FollowUserMutationResult = NonNullable<Awaited<ReturnType<typeof followUser>>>
    
    export type FollowUserMutationError = FollowUser404

    export const useFollowUser = <TError = FollowUser404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof followUser>>,
        TError,
        {userId: string;headers: FollowUserHeaders},
        TContext
      > => {

      const mutationOptions = getFollowUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type removeFollowResponse204 = {
  data: RemoveFollow204
  status: 204
}

export type removeFollowResponse400 = {
  data: RemoveFollow400
  status: 400
}
    
export type removeFollowResponseSuccess = (removeFollowResponse204) & {
  headers: Headers;
};
export type removeFollowResponseError = (removeFollowResponse400) & {
  headers: Headers;
};

export type removeFollowResponse = (removeFollowResponseSuccess | removeFollowResponseError)

export const getRemoveFollowUrl = (userId: string,) => {


  

  return `http://localhost:3001/follows/${userId}`
}

export const removeFollow = async (userId: string,
    removeFollowBody: RemoveFollowBody,
    headers: RemoveFollowHeaders, options?: RequestInit): Promise<removeFollowResponse> => {
  
  const res = await fetch(getRemoveFollowUrl(userId),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      removeFollowBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeFollowResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeFollowResponse
}




export const getRemoveFollowMutationOptions = <TError = RemoveFollow400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext> => {

const mutationKey = ['removeFollow'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFollow>>, {userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}> = (props) => {
          const {userId,data,headers} = props ?? {};

          return  removeFollow(userId,data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFollowMutationResult = NonNullable<Awaited<ReturnType<typeof removeFollow>>>
    export type RemoveFollowMutationBody = RemoveFollowBody
    export type RemoveFollowMutationError = RemoveFollow400

    export const useRemoveFollow = <TError = RemoveFollow400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFollow>>,
        TError,
        {userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders},
        TContext
      > => {

      const mutationOptions = getRemoveFollowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type respondToFollowResponse200 = {
  data: RespondToFollow200
  status: 200
}

export type respondToFollowResponse404 = {
  data: RespondToFollow404
  status: 404
}

export type respondToFollowResponse412 = {
  data: RespondToFollow412
  status: 412
}
    
export type respondToFollowResponseSuccess = (respondToFollowResponse200) & {
  headers: Headers;
};
export type respondToFollowResponseError = (respondToFollowResponse404 | respondToFollowResponse412) & {
  headers: Headers;
};

export type respondToFollowResponse = (respondToFollowResponseSuccess | respondToFollowResponseError)

export const getRespondToFollowUrl = (userId: string,) => {


  

  return `http://localhost:3001/follows/respond/${userId}`
}

export const respondToFollow = async (userId: string,
    respondToFollowBody: RespondToFollowBody,
    headers: RespondToFollowHeaders, options?: RequestInit): Promise<respondToFollowResponse> => {
  
  const res = await fetch(getRespondToFollowUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      respondToFollowBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: respondToFollowResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as respondToFollowResponse
}




export const getRespondToFollowMutationOptions = <TError = RespondToFollow404 | RespondToFollow412,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext> => {

const mutationKey = ['respondToFollow'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof respondToFollow>>, {userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}> = (props) => {
          const {userId,data,headers} = props ?? {};

          return  respondToFollow(userId,data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RespondToFollowMutationResult = NonNullable<Awaited<ReturnType<typeof respondToFollow>>>
    export type RespondToFollowMutationBody = RespondToFollowBody
    export type RespondToFollowMutationError = RespondToFollow404 | RespondToFollow412

    export const useRespondToFollow = <TError = RespondToFollow404 | RespondToFollow412,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof respondToFollow>>,
        TError,
        {userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders},
        TContext
      > => {

      const mutationOptions = getRespondToFollowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createIntentionResponse201 = {
  data: CreateIntention201
  status: 201
}

export type createIntentionResponse409 = {
  data: CreateIntention409
  status: 409
}
    
export type createIntentionResponseSuccess = (createIntentionResponse201) & {
  headers: Headers;
};
export type createIntentionResponseError = (createIntentionResponse409) & {
  headers: Headers;
};

export type createIntentionResponse = (createIntentionResponseSuccess | createIntentionResponseError)

export const getCreateIntentionUrl = () => {


  

  return `http://localhost:3001/intentions`
}

export const createIntention = async (createIntentionBody: CreateIntentionBody,
    headers: CreateIntentionHeaders, options?: RequestInit): Promise<createIntentionResponse> => {
  
  const res = await fetch(getCreateIntentionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createIntentionBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createIntentionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createIntentionResponse
}




export const getCreateIntentionMutationOptions = <TError = CreateIntention409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext> => {

const mutationKey = ['createIntention'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createIntention>>, {data: CreateIntentionBody;headers: CreateIntentionHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createIntention(data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateIntentionMutationResult = NonNullable<Awaited<ReturnType<typeof createIntention>>>
    export type CreateIntentionMutationBody = CreateIntentionBody
    export type CreateIntentionMutationError = CreateIntention409

    export const useCreateIntention = <TError = CreateIntention409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createIntention>>,
        TError,
        {data: CreateIntentionBody;headers: CreateIntentionHeaders},
        TContext
      > => {

      const mutationOptions = getCreateIntentionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createPostResponse201 = {
  data: CreatePost201
  status: 201
}

export type createPostResponse404 = {
  data: CreatePost404
  status: 404
}
    
export type createPostResponseSuccess = (createPostResponse201) & {
  headers: Headers;
};
export type createPostResponseError = (createPostResponse404) & {
  headers: Headers;
};

export type createPostResponse = (createPostResponseSuccess | createPostResponseError)

export const getCreatePostUrl = () => {


  

  return `http://localhost:3001/posts`
}

export const createPost = async (createPostBody: CreatePostBody,
    headers: CreatePostHeaders, options?: RequestInit): Promise<createPostResponse> => {
  
  const res = await fetch(getCreatePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createPostResponse
}




export const getCreatePostMutationOptions = <TError = CreatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext> => {

const mutationKey = ['createPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPost>>, {data: CreatePostBody;headers: CreatePostHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createPost(data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createPost>>>
    export type CreatePostMutationBody = CreatePostBody
    export type CreatePostMutationError = CreatePost404

    export const useCreatePost = <TError = CreatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPost>>,
        TError,
        {data: CreatePostBody;headers: CreatePostHeaders},
        TContext
      > => {

      const mutationOptions = getCreatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updatePostResponse200 = {
  data: UpdatePost200
  status: 200
}

export type updatePostResponse404 = {
  data: UpdatePost404
  status: 404
}
    
export type updatePostResponseSuccess = (updatePostResponse200) & {
  headers: Headers;
};
export type updatePostResponseError = (updatePostResponse404) & {
  headers: Headers;
};

export type updatePostResponse = (updatePostResponseSuccess | updatePostResponseError)

export const getUpdatePostUrl = (id: string,) => {


  

  return `http://localhost:3001/posts/${id}`
}

export const updatePost = async (id: string,
    updatePostBody: UpdatePostBody,
    headers: UpdatePostHeaders, options?: RequestInit): Promise<updatePostResponse> => {
  
  const res = await fetch(getUpdatePostUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      updatePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updatePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updatePostResponse
}




export const getUpdatePostMutationOptions = <TError = UpdatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext> => {

const mutationKey = ['updatePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePost>>, {id: string;data: UpdatePostBody;headers: UpdatePostHeaders}> = (props) => {
          const {id,data,headers} = props ?? {};

          return  updatePost(id,data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePost>>>
    export type UpdatePostMutationBody = UpdatePostBody
    export type UpdatePostMutationError = UpdatePost404

    export const useUpdatePost = <TError = UpdatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePost>>,
        TError,
        {id: string;data: UpdatePostBody;headers: UpdatePostHeaders},
        TContext
      > => {

      const mutationOptions = getUpdatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type deletePostResponse204 = {
  data: DeletePost204
  status: 204
}
    
export type deletePostResponseSuccess = (deletePostResponse204) & {
  headers: Headers;
};
;

export type deletePostResponse = (deletePostResponseSuccess)

export const getDeletePostUrl = (id: string,) => {


  

  return `http://localhost:3001/posts/${id}`
}

export const deletePost = async (id: string,
    headers: DeletePostHeaders, options?: RequestInit): Promise<deletePostResponse> => {
  
  const res = await fetch(getDeletePostUrl(id),
  {      
    ...options,
    method: 'DELETE',
    headers: { ...headers, ...options?.headers }
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePostResponse
}




export const getDeletePostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext> => {

const mutationKey = ['deletePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePost>>, {id: string;headers: DeletePostHeaders}> = (props) => {
          const {id,headers} = props ?? {};

          return  deletePost(id,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePost>>>
    
    export type DeletePostMutationError = unknown

    export const useDeletePost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePost>>,
        TError,
        {id: string;headers: DeletePostHeaders},
        TContext
      > => {

      const mutationOptions = getDeletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createUserResponse201 = {
  data: CreateUser201
  status: 201
}

export type createUserResponse400 = {
  data: CreateUser400
  status: 400
}

export type createUserResponse409 = {
  data: CreateUser409
  status: 409
}
    
export type createUserResponseSuccess = (createUserResponse201) & {
  headers: Headers;
};
export type createUserResponseError = (createUserResponse400 | createUserResponse409) & {
  headers: Headers;
};

export type createUserResponse = (createUserResponseSuccess | createUserResponseError)

export const getCreateUserUrl = () => {


  

  return `http://localhost:3001/users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUserResponse
}




export const getCreateUserMutationOptions = <TError = CreateUser400 | CreateUser409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = CreateUser400 | CreateUser409

    export const useCreateUser = <TError = CreateUser400 | CreateUser409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updateUserResponse200 = {
  data: UpdateUser200
  status: 200
}
    
export type updateUserResponseSuccess = (updateUserResponse200) & {
  headers: Headers;
};
;

export type updateUserResponse = (updateUserResponseSuccess)

export const getUpdateUserUrl = () => {


  

  return `http://localhost:3001/users`
}

export const updateUser = async (updateUserBody: UpdateUserBody,
    headers: UpdateUserHeaders, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserResponse
}




export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody;headers: UpdateUserHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody;headers: UpdateUserHeaders}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserBody;headers: UpdateUserHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  updateUser(data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = unknown

    export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserBody;headers: UpdateUserHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserBody;headers: UpdateUserHeaders},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createCommentResponse201 = {
  data: CreateComment201
  status: 201
}

export type createCommentResponse404 = {
  data: CreateComment404
  status: 404
}
    
export type createCommentResponseSuccess = (createCommentResponse201) & {
  headers: Headers;
};
export type createCommentResponseError = (createCommentResponse404) & {
  headers: Headers;
};

export type createCommentResponse = (createCommentResponseSuccess | createCommentResponseError)

export const getCreateCommentUrl = () => {


  

  return `http://localhost:3001/comments`
}

export const createComment = async (createCommentBody: CreateCommentBody,
    headers: CreateCommentHeaders, options?: RequestInit): Promise<createCommentResponse> => {
  
  const res = await fetch(getCreateCommentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createCommentBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCommentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCommentResponse
}




export const getCreateCommentMutationOptions = <TError = CreateComment404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext> => {

const mutationKey = ['createComment'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {data: CreateCommentBody;headers: CreateCommentHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createComment(data,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = CreateCommentBody
    export type CreateCommentMutationError = CreateComment404

    export const useCreateComment = <TError = CreateComment404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {data: CreateCommentBody;headers: CreateCommentHeaders},
        TContext
      > => {

      const mutationOptions = getCreateCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type deleteCommentResponse204 = {
  data: DeleteComment204
  status: 204
}
    
export type deleteCommentResponseSuccess = (deleteCommentResponse204) & {
  headers: Headers;
};
;

export type deleteCommentResponse = (deleteCommentResponseSuccess)

export const getDeleteCommentUrl = (id: string,) => {


  

  return `http://localhost:3001/comments/${id}`
}

export const deleteComment = async (id: string,
    headers: DeleteCommentHeaders, options?: RequestInit): Promise<deleteCommentResponse> => {
  
  const res = await fetch(getDeleteCommentUrl(id),
  {      
    ...options,
    method: 'DELETE',
    headers: { ...headers, ...options?.headers }
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCommentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCommentResponse
}




export const getDeleteCommentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext> => {

const mutationKey = ['deleteComment'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteComment>>, {id: string;headers: DeleteCommentHeaders}> = (props) => {
          const {id,headers} = props ?? {};

          return  deleteComment(id,headers,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>
    
    export type DeleteCommentMutationError = unknown

    export const useDeleteComment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteComment>>,
        TError,
        {id: string;headers: DeleteCommentHeaders},
        TContext
      > => {

      const mutationOptions = getDeleteCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
