/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Intentions API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import { customFetch } from '../orval.mutator';
export type FollowUserHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type FollowUser201 = unknown | null;

/**
 * @nullable
 */
export type FollowUser401 = unknown | null;

export type FollowUser404 = {
  message: string;
};

export type RemoveFollowHeaders = {
authorization: string;
};

export type RemoveFollowBodyDirection = typeof RemoveFollowBodyDirection[keyof typeof RemoveFollowBodyDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemoveFollowBodyDirection = {
  to: 'to',
  from: 'from',
} as const;

export type RemoveFollowBody = {
  direction: RemoveFollowBodyDirection;
};

/**
 * @nullable
 */
export type RemoveFollow200 = unknown | null;

export type RemoveFollow400 = {
  message: string;
};

/**
 * @nullable
 */
export type RemoveFollow401 = unknown | null;

export type RespondToFollowHeaders = {
authorization: string;
};

export type RespondToFollowBodyAction = typeof RespondToFollowBodyAction[keyof typeof RespondToFollowBodyAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RespondToFollowBodyAction = {
  accept: 'accept',
  decline: 'decline',
} as const;

export type RespondToFollowBody = {
  action: RespondToFollowBodyAction;
};

/**
 * @nullable
 */
export type RespondToFollow200 = unknown | null;

/**
 * @nullable
 */
export type RespondToFollow401 = unknown | null;

export type RespondToFollow404 = {
  message: string;
};

export type RespondToFollow412 = {
  message: string;
};

export type CreateIntentionHeaders = {
authorization: string;
};

export type CreateIntentionBody = {
  /** @minLength 1 */
  name: string;
};

export type CreateIntention201 = {
  id: string;
};

/**
 * @nullable
 */
export type CreateIntention401 = unknown | null;

export type CreateIntention409 = {
  message: string;
};

export type CreatePostHeaders = {
authorization: string;
};

export type CreatePostBody = {
  intentionId: string;
  image?: string;
  description?: string;
};

/**
 * @nullable
 */
export type CreatePost201 = unknown | null;

/**
 * @nullable
 */
export type CreatePost401 = unknown | null;

export type CreatePost404 = {
  message: string;
};

export type UpdatePostHeaders = {
authorization: string;
};

export type UpdatePostBody = {
  description?: string;
};

/**
 * @nullable
 */
export type UpdatePost200 = unknown | null;

/**
 * @nullable
 */
export type UpdatePost401 = unknown | null;

export type UpdatePost404 = {
  message: string;
};

export type DeletePostHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type DeletePost200 = unknown | null;

/**
 * @nullable
 */
export type DeletePost401 = unknown | null;

export type CreateUserBody = {
  username: string;
  email: string;
  password: string;
};

/**
 * @nullable
 */
export type CreateUser201 = unknown | null;

export type CreateUser400 = {
  message: string;
};

export type CreateUser409 = {
  message: string;
};

export type UpdateUserImageHeaders = {
authorization: string;
};

export type UpdateUserImageBody = {
  image: string;
};

/**
 * @nullable
 */
export type UpdateUserImage200 = unknown | null;

/**
 * @nullable
 */
export type UpdateUserImage401 = unknown | null;

export type ClearNotifAlertHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type ClearNotifAlert200 = unknown | null;

/**
 * @nullable
 */
export type ClearNotifAlert401 = unknown | null;

export type CreateCommentHeaders = {
authorization: string;
};

export type CreateCommentBody = {
  postId: string;
  body: string;
};

/**
 * @nullable
 */
export type CreateComment201 = unknown | null;

/**
 * @nullable
 */
export type CreateComment401 = unknown | null;

export type CreateComment404 = {
  message: string;
};

export type DeleteCommentHeaders = {
authorization: string;
};

/**
 * @nullable
 */
export type DeleteComment200 = unknown | null;

/**
 * @nullable
 */
export type DeleteComment401 = unknown | null;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type followUserResponse201 = {
  data: FollowUser201
  status: 201
}

export type followUserResponse401 = {
  data: FollowUser401
  status: 401
}

export type followUserResponse404 = {
  data: FollowUser404
  status: 404
}
    
export type followUserResponseSuccess = (followUserResponse201) & {
  headers: Headers;
};
export type followUserResponseError = (followUserResponse401 | followUserResponse404) & {
  headers: Headers;
};

export type followUserResponse = (followUserResponseSuccess | followUserResponseError)

export const getFollowUserUrl = (userId: string,) => {


  

  return `/follows/${userId}`
}

export const followUser = async (userId: string,
    headers: FollowUserHeaders, options?: RequestInit): Promise<followUserResponse> => {
  
  return customFetch<followUserResponse>(getFollowUserUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { ...headers, ...options?.headers }
    
  }
);}




export const getFollowUserMutationOptions = <TError = FollowUser401 | FollowUser404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext> => {

const mutationKey = ['followUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof followUser>>, {userId: string;headers: FollowUserHeaders}> = (props) => {
          const {userId,headers} = props ?? {};

          return  followUser(userId,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FollowUserMutationResult = NonNullable<Awaited<ReturnType<typeof followUser>>>
    
    export type FollowUserMutationError = FollowUser401 | FollowUser404

    export const useFollowUser = <TError = FollowUser401 | FollowUser404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof followUser>>, TError,{userId: string;headers: FollowUserHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof followUser>>,
        TError,
        {userId: string;headers: FollowUserHeaders},
        TContext
      > => {

      const mutationOptions = getFollowUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type removeFollowResponse200 = {
  data: RemoveFollow200
  status: 200
}

export type removeFollowResponse400 = {
  data: RemoveFollow400
  status: 400
}

export type removeFollowResponse401 = {
  data: RemoveFollow401
  status: 401
}
    
export type removeFollowResponseSuccess = (removeFollowResponse200) & {
  headers: Headers;
};
export type removeFollowResponseError = (removeFollowResponse400 | removeFollowResponse401) & {
  headers: Headers;
};

export type removeFollowResponse = (removeFollowResponseSuccess | removeFollowResponseError)

export const getRemoveFollowUrl = (userId: string,) => {


  

  return `/follows/${userId}`
}

export const removeFollow = async (userId: string,
    removeFollowBody: RemoveFollowBody,
    headers: RemoveFollowHeaders, options?: RequestInit): Promise<removeFollowResponse> => {
  
  return customFetch<removeFollowResponse>(getRemoveFollowUrl(userId),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      removeFollowBody,)
  }
);}




export const getRemoveFollowMutationOptions = <TError = RemoveFollow400 | RemoveFollow401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext> => {

const mutationKey = ['removeFollow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFollow>>, {userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}> = (props) => {
          const {userId,data,headers} = props ?? {};

          return  removeFollow(userId,data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFollowMutationResult = NonNullable<Awaited<ReturnType<typeof removeFollow>>>
    export type RemoveFollowMutationBody = RemoveFollowBody
    export type RemoveFollowMutationError = RemoveFollow400 | RemoveFollow401

    export const useRemoveFollow = <TError = RemoveFollow400 | RemoveFollow401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFollow>>, TError,{userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFollow>>,
        TError,
        {userId: string;data: RemoveFollowBody;headers: RemoveFollowHeaders},
        TContext
      > => {

      const mutationOptions = getRemoveFollowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type respondToFollowResponse200 = {
  data: RespondToFollow200
  status: 200
}

export type respondToFollowResponse401 = {
  data: RespondToFollow401
  status: 401
}

export type respondToFollowResponse404 = {
  data: RespondToFollow404
  status: 404
}

export type respondToFollowResponse412 = {
  data: RespondToFollow412
  status: 412
}
    
export type respondToFollowResponseSuccess = (respondToFollowResponse200) & {
  headers: Headers;
};
export type respondToFollowResponseError = (respondToFollowResponse401 | respondToFollowResponse404 | respondToFollowResponse412) & {
  headers: Headers;
};

export type respondToFollowResponse = (respondToFollowResponseSuccess | respondToFollowResponseError)

export const getRespondToFollowUrl = (userId: string,) => {


  

  return `/follows/respond/${userId}`
}

export const respondToFollow = async (userId: string,
    respondToFollowBody: RespondToFollowBody,
    headers: RespondToFollowHeaders, options?: RequestInit): Promise<respondToFollowResponse> => {
  
  return customFetch<respondToFollowResponse>(getRespondToFollowUrl(userId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      respondToFollowBody,)
  }
);}




export const getRespondToFollowMutationOptions = <TError = RespondToFollow401 | RespondToFollow404 | RespondToFollow412,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext> => {

const mutationKey = ['respondToFollow'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof respondToFollow>>, {userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}> = (props) => {
          const {userId,data,headers} = props ?? {};

          return  respondToFollow(userId,data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RespondToFollowMutationResult = NonNullable<Awaited<ReturnType<typeof respondToFollow>>>
    export type RespondToFollowMutationBody = RespondToFollowBody
    export type RespondToFollowMutationError = RespondToFollow401 | RespondToFollow404 | RespondToFollow412

    export const useRespondToFollow = <TError = RespondToFollow401 | RespondToFollow404 | RespondToFollow412,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof respondToFollow>>, TError,{userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof respondToFollow>>,
        TError,
        {userId: string;data: RespondToFollowBody;headers: RespondToFollowHeaders},
        TContext
      > => {

      const mutationOptions = getRespondToFollowMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createIntentionResponse201 = {
  data: CreateIntention201
  status: 201
}

export type createIntentionResponse401 = {
  data: CreateIntention401
  status: 401
}

export type createIntentionResponse409 = {
  data: CreateIntention409
  status: 409
}
    
export type createIntentionResponseSuccess = (createIntentionResponse201) & {
  headers: Headers;
};
export type createIntentionResponseError = (createIntentionResponse401 | createIntentionResponse409) & {
  headers: Headers;
};

export type createIntentionResponse = (createIntentionResponseSuccess | createIntentionResponseError)

export const getCreateIntentionUrl = () => {


  

  return `/intentions`
}

export const createIntention = async (createIntentionBody: CreateIntentionBody,
    headers: CreateIntentionHeaders, options?: RequestInit): Promise<createIntentionResponse> => {
  
  return customFetch<createIntentionResponse>(getCreateIntentionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createIntentionBody,)
  }
);}




export const getCreateIntentionMutationOptions = <TError = CreateIntention401 | CreateIntention409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext> => {

const mutationKey = ['createIntention'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createIntention>>, {data: CreateIntentionBody;headers: CreateIntentionHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createIntention(data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateIntentionMutationResult = NonNullable<Awaited<ReturnType<typeof createIntention>>>
    export type CreateIntentionMutationBody = CreateIntentionBody
    export type CreateIntentionMutationError = CreateIntention401 | CreateIntention409

    export const useCreateIntention = <TError = CreateIntention401 | CreateIntention409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIntention>>, TError,{data: CreateIntentionBody;headers: CreateIntentionHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createIntention>>,
        TError,
        {data: CreateIntentionBody;headers: CreateIntentionHeaders},
        TContext
      > => {

      const mutationOptions = getCreateIntentionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createPostResponse201 = {
  data: CreatePost201
  status: 201
}

export type createPostResponse401 = {
  data: CreatePost401
  status: 401
}

export type createPostResponse404 = {
  data: CreatePost404
  status: 404
}
    
export type createPostResponseSuccess = (createPostResponse201) & {
  headers: Headers;
};
export type createPostResponseError = (createPostResponse401 | createPostResponse404) & {
  headers: Headers;
};

export type createPostResponse = (createPostResponseSuccess | createPostResponseError)

export const getCreatePostUrl = () => {


  

  return `/posts`
}

export const createPost = async (createPostBody: CreatePostBody,
    headers: CreatePostHeaders, options?: RequestInit): Promise<createPostResponse> => {
  
  return customFetch<createPostResponse>(getCreatePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createPostBody,)
  }
);}




export const getCreatePostMutationOptions = <TError = CreatePost401 | CreatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext> => {

const mutationKey = ['createPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPost>>, {data: CreatePostBody;headers: CreatePostHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createPost(data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createPost>>>
    export type CreatePostMutationBody = CreatePostBody
    export type CreatePostMutationError = CreatePost401 | CreatePost404

    export const useCreatePost = <TError = CreatePost401 | CreatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError,{data: CreatePostBody;headers: CreatePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPost>>,
        TError,
        {data: CreatePostBody;headers: CreatePostHeaders},
        TContext
      > => {

      const mutationOptions = getCreatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updatePostResponse200 = {
  data: UpdatePost200
  status: 200
}

export type updatePostResponse401 = {
  data: UpdatePost401
  status: 401
}

export type updatePostResponse404 = {
  data: UpdatePost404
  status: 404
}
    
export type updatePostResponseSuccess = (updatePostResponse200) & {
  headers: Headers;
};
export type updatePostResponseError = (updatePostResponse401 | updatePostResponse404) & {
  headers: Headers;
};

export type updatePostResponse = (updatePostResponseSuccess | updatePostResponseError)

export const getUpdatePostUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const updatePost = async (id: string,
    updatePostBody: UpdatePostBody,
    headers: UpdatePostHeaders, options?: RequestInit): Promise<updatePostResponse> => {
  
  return customFetch<updatePostResponse>(getUpdatePostUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      updatePostBody,)
  }
);}




export const getUpdatePostMutationOptions = <TError = UpdatePost401 | UpdatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext> => {

const mutationKey = ['updatePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePost>>, {id: string;data: UpdatePostBody;headers: UpdatePostHeaders}> = (props) => {
          const {id,data,headers} = props ?? {};

          return  updatePost(id,data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePost>>>
    export type UpdatePostMutationBody = UpdatePostBody
    export type UpdatePostMutationError = UpdatePost401 | UpdatePost404

    export const useUpdatePost = <TError = UpdatePost401 | UpdatePost404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError,{id: string;data: UpdatePostBody;headers: UpdatePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePost>>,
        TError,
        {id: string;data: UpdatePostBody;headers: UpdatePostHeaders},
        TContext
      > => {

      const mutationOptions = getUpdatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type deletePostResponse200 = {
  data: DeletePost200
  status: 200
}

export type deletePostResponse401 = {
  data: DeletePost401
  status: 401
}
    
export type deletePostResponseSuccess = (deletePostResponse200) & {
  headers: Headers;
};
export type deletePostResponseError = (deletePostResponse401) & {
  headers: Headers;
};

export type deletePostResponse = (deletePostResponseSuccess | deletePostResponseError)

export const getDeletePostUrl = (id: string,) => {


  

  return `/posts/${id}`
}

export const deletePost = async (id: string,
    headers: DeletePostHeaders, options?: RequestInit): Promise<deletePostResponse> => {
  
  return customFetch<deletePostResponse>(getDeletePostUrl(id),
  {      
    ...options,
    method: 'DELETE',
    headers: { ...headers, ...options?.headers }
    
  }
);}




export const getDeletePostMutationOptions = <TError = DeletePost401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext> => {

const mutationKey = ['deletePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePost>>, {id: string;headers: DeletePostHeaders}> = (props) => {
          const {id,headers} = props ?? {};

          return  deletePost(id,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePost>>>
    
    export type DeletePostMutationError = DeletePost401

    export const useDeletePost = <TError = DeletePost401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError,{id: string;headers: DeletePostHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePost>>,
        TError,
        {id: string;headers: DeletePostHeaders},
        TContext
      > => {

      const mutationOptions = getDeletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createUserResponse201 = {
  data: CreateUser201
  status: 201
}

export type createUserResponse400 = {
  data: CreateUser400
  status: 400
}

export type createUserResponse409 = {
  data: CreateUser409
  status: 409
}
    
export type createUserResponseSuccess = (createUserResponse201) & {
  headers: Headers;
};
export type createUserResponseError = (createUserResponse400 | createUserResponse409) & {
  headers: Headers;
};

export type createUserResponse = (createUserResponseSuccess | createUserResponseError)

export const getCreateUserUrl = () => {


  

  return `/users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
  
  return customFetch<createUserResponse>(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
);}




export const getCreateUserMutationOptions = <TError = CreateUser400 | CreateUser409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = CreateUser400 | CreateUser409

    export const useCreateUser = <TError = CreateUser400 | CreateUser409,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updateUserImageResponse200 = {
  data: UpdateUserImage200
  status: 200
}

export type updateUserImageResponse401 = {
  data: UpdateUserImage401
  status: 401
}
    
export type updateUserImageResponseSuccess = (updateUserImageResponse200) & {
  headers: Headers;
};
export type updateUserImageResponseError = (updateUserImageResponse401) & {
  headers: Headers;
};

export type updateUserImageResponse = (updateUserImageResponseSuccess | updateUserImageResponseError)

export const getUpdateUserImageUrl = () => {


  

  return `/users/image`
}

export const updateUserImage = async (updateUserImageBody: UpdateUserImageBody,
    headers: UpdateUserImageHeaders, options?: RequestInit): Promise<updateUserImageResponse> => {
  
  return customFetch<updateUserImageResponse>(getUpdateUserImageUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      updateUserImageBody,)
  }
);}




export const getUpdateUserImageMutationOptions = <TError = UpdateUserImage401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserImage>>, TError,{data: UpdateUserImageBody;headers: UpdateUserImageHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserImage>>, TError,{data: UpdateUserImageBody;headers: UpdateUserImageHeaders}, TContext> => {

const mutationKey = ['updateUserImage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserImage>>, {data: UpdateUserImageBody;headers: UpdateUserImageHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  updateUserImage(data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserImageMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserImage>>>
    export type UpdateUserImageMutationBody = UpdateUserImageBody
    export type UpdateUserImageMutationError = UpdateUserImage401

    export const useUpdateUserImage = <TError = UpdateUserImage401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserImage>>, TError,{data: UpdateUserImageBody;headers: UpdateUserImageHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserImage>>,
        TError,
        {data: UpdateUserImageBody;headers: UpdateUserImageHeaders},
        TContext
      > => {

      const mutationOptions = getUpdateUserImageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type clearNotifAlertResponse200 = {
  data: ClearNotifAlert200
  status: 200
}

export type clearNotifAlertResponse401 = {
  data: ClearNotifAlert401
  status: 401
}
    
export type clearNotifAlertResponseSuccess = (clearNotifAlertResponse200) & {
  headers: Headers;
};
export type clearNotifAlertResponseError = (clearNotifAlertResponse401) & {
  headers: Headers;
};

export type clearNotifAlertResponse = (clearNotifAlertResponseSuccess | clearNotifAlertResponseError)

export const getClearNotifAlertUrl = () => {


  

  return `/users/notif-alert`
}

export const clearNotifAlert = async (headers: ClearNotifAlertHeaders, options?: RequestInit): Promise<clearNotifAlertResponse> => {
  
  return customFetch<clearNotifAlertResponse>(getClearNotifAlertUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { ...headers, ...options?.headers }
    
  }
);}




export const getClearNotifAlertMutationOptions = <TError = ClearNotifAlert401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearNotifAlert>>, TError,{headers: ClearNotifAlertHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof clearNotifAlert>>, TError,{headers: ClearNotifAlertHeaders}, TContext> => {

const mutationKey = ['clearNotifAlert'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearNotifAlert>>, {headers: ClearNotifAlertHeaders}> = (props) => {
          const {headers} = props ?? {};

          return  clearNotifAlert(headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearNotifAlertMutationResult = NonNullable<Awaited<ReturnType<typeof clearNotifAlert>>>
    
    export type ClearNotifAlertMutationError = ClearNotifAlert401

    export const useClearNotifAlert = <TError = ClearNotifAlert401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearNotifAlert>>, TError,{headers: ClearNotifAlertHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearNotifAlert>>,
        TError,
        {headers: ClearNotifAlertHeaders},
        TContext
      > => {

      const mutationOptions = getClearNotifAlertMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createCommentResponse201 = {
  data: CreateComment201
  status: 201
}

export type createCommentResponse401 = {
  data: CreateComment401
  status: 401
}

export type createCommentResponse404 = {
  data: CreateComment404
  status: 404
}
    
export type createCommentResponseSuccess = (createCommentResponse201) & {
  headers: Headers;
};
export type createCommentResponseError = (createCommentResponse401 | createCommentResponse404) & {
  headers: Headers;
};

export type createCommentResponse = (createCommentResponseSuccess | createCommentResponseError)

export const getCreateCommentUrl = () => {


  

  return `/comments`
}

export const createComment = async (createCommentBody: CreateCommentBody,
    headers: CreateCommentHeaders, options?: RequestInit): Promise<createCommentResponse> => {
  
  return customFetch<createCommentResponse>(getCreateCommentUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json',...headers, ...options?.headers },
    body: JSON.stringify(
      createCommentBody,)
  }
);}




export const getCreateCommentMutationOptions = <TError = CreateComment401 | CreateComment404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext> => {

const mutationKey = ['createComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {data: CreateCommentBody;headers: CreateCommentHeaders}> = (props) => {
          const {data,headers} = props ?? {};

          return  createComment(data,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = CreateCommentBody
    export type CreateCommentMutationError = CreateComment401 | CreateComment404

    export const useCreateComment = <TError = CreateComment401 | CreateComment404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: CreateCommentBody;headers: CreateCommentHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {data: CreateCommentBody;headers: CreateCommentHeaders},
        TContext
      > => {

      const mutationOptions = getCreateCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type deleteCommentResponse200 = {
  data: DeleteComment200
  status: 200
}

export type deleteCommentResponse401 = {
  data: DeleteComment401
  status: 401
}
    
export type deleteCommentResponseSuccess = (deleteCommentResponse200) & {
  headers: Headers;
};
export type deleteCommentResponseError = (deleteCommentResponse401) & {
  headers: Headers;
};

export type deleteCommentResponse = (deleteCommentResponseSuccess | deleteCommentResponseError)

export const getDeleteCommentUrl = (id: string,) => {


  

  return `/comments/${id}`
}

export const deleteComment = async (id: string,
    headers: DeleteCommentHeaders, options?: RequestInit): Promise<deleteCommentResponse> => {
  
  return customFetch<deleteCommentResponse>(getDeleteCommentUrl(id),
  {      
    ...options,
    method: 'DELETE',
    headers: { ...headers, ...options?.headers }
    
  }
);}




export const getDeleteCommentMutationOptions = <TError = DeleteComment401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext> => {

const mutationKey = ['deleteComment'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteComment>>, {id: string;headers: DeleteCommentHeaders}> = (props) => {
          const {id,headers} = props ?? {};

          return  deleteComment(id,headers,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>
    
    export type DeleteCommentMutationError = DeleteComment401

    export const useDeleteComment = <TError = DeleteComment401,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteComment>>, TError,{id: string;headers: DeleteCommentHeaders}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteComment>>,
        TError,
        {id: string;headers: DeleteCommentHeaders},
        TContext
      > => {

      const mutationOptions = getDeleteCommentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
